// =====================================
// SERVER.TS CORRIG√â - SINGLETON PRISMA
// =====================================

import Fastify from 'fastify'
import cors from '@fastify/cors'
import helmet from '@fastify/helmet'
import rateLimit from '@fastify/rate-limit'
import dotenv from 'dotenv'

// ‚úÖ IMPORT DU SINGLETON PRISMA - PLUS D'INSTANCE MULTIPLE
import prisma, { testDatabaseConnection, getConnectionStatus } from './lib/prisma'

// ‚úÖ IMPORT DES NOUVEAUX MODULES SUPABASE
import { supabaseServiceClient, supabaseAuthClient, testSupabaseConnection } from './lib/supabase'
import { authenticate, optionalAuthenticate } from './middleware/auth'

// ‚úÖ IMPORT DE TOUTES LES ROUTES EXISTANTES
import billingRoutes from './routes/billing'
import agentsRoutes from './routes/agents' 
import productsRoutes from './routes/products'
import publicRoutes from './routes/public' 
import ordersRoutes from './routes/orders'
import shopsRoutes from './routes/shops'
import knowledgeBaseRoutes from './routes/knowledge-base'
import conversationsRoutes from './routes/conversations'
import chatRoutes from './routes/chat'

// Load environment variables
dotenv.config()

// ‚úÖ VALIDATION VARIABLES D'ENVIRONNEMENT
const requiredEnvVars = {
  DATABASE_URL: process.env.DATABASE_URL,
  SUPABASE_URL: process.env.SUPABASE_URL,
  SUPABASE_SERVICE_KEY: process.env.SUPABASE_SERVICE_KEY,
  SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY,
  OPENAI_API_KEY: process.env.OPENAI_API_KEY 
}

for (const [key, value] of Object.entries(requiredEnvVars)) {
  if (!value) {
    console.error(`‚ùå Variable d'environnement manquante: ${key}`)
    process.exit(1)
  }
}

console.log('‚úÖ Variables d\'environnement valid√©es')

// Create Fastify instance
const fastify = Fastify({
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    transport: process.env.NODE_ENV === 'development' ? {
      target: 'pino-pretty',
      options: {
        colorize: true
      }
    } : undefined
  }
})

// Register plugins
async function registerPlugins() {
  // Security
  await fastify.register(helmet, {
    contentSecurityPolicy: false
  })

  // ‚úÖ CORS OPTIMIS√â POUR LE WIDGET EMBEDDABLE - CRITIQUE
  await fastify.register(cors, {
    origin: (origin, callback) => {
      // ‚úÖ IMPORTANT: Autoriser tous les domaines pour le widget embeddable
      callback(null, true)
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept']
  })

  // ‚úÖ RATE LIMITING ADAPT√â AU WIDGET
  await fastify.register(rateLimit, {
    max: parseInt(process.env.RATE_LIMIT_MAX || '300'),
    timeWindow: parseInt(process.env.RATE_LIMIT_WINDOW || '60000'),
    keyGenerator: (request) => {
      return `${request.ip}-${request.headers['user-agent']?.slice(0, 50) || 'unknown'}`
    }
  })
}

// Routes
async function registerRoutes() {
  
  // ‚úÖ HEALTH CHECK CORRIG√â SANS PREPARED STATEMENTS
  fastify.get('/health', async (request, reply) => {
    const healthData = {
      status: 'ok',
      timestamp: new Date().toISOString(),
      version: process.env.npm_package_version || '1.0.0',
      environment: process.env.NODE_ENV || 'development',
      services: {
        database: 'checking...',
        openai: 'checking...',
        supabase: 'checking...'
      }
    }

    // ‚úÖ TEST DATABASE AVEC NOUVELLE M√âTHODE SANS CONFLITS
    try {
      const dbStatus = await testDatabaseConnection()
      healthData.services.database = dbStatus.success ? 'ok' : 'error'
      
      if (!dbStatus.success) {
        console.error('‚ùå Database health check failed:', dbStatus.error)
        healthData.status = 'degraded'
      }
    } catch (error) {
      console.error('‚ùå Database health check failed:', error)
      healthData.services.database = 'error'
      healthData.status = 'degraded'
    }

    // Test OpenAI
    healthData.services.openai = process.env.OPENAI_API_KEY ? 'configured' : 'not_configured'

    // ‚úÖ TEST SUPABASE AVEC NOUVELLE FONCTION
    const supabaseTest = await testSupabaseConnection()
    healthData.services.supabase = supabaseTest.success ? 'ok' : 'error'
    
    if (!supabaseTest.success) {
      console.error('‚ùå Supabase health check failed:', supabaseTest.error)
      healthData.status = 'degraded'
    }

    return healthData
  })

  // ‚úÖ ROUTE RACINE
  fastify.get('/', async (request, reply) => {
    return {
      success: true,
      message: 'ChatSeller API is running',
      version: '1.3.0',
      timestamp: new Date().toISOString(),
      endpoints: {
        health: '/health',
        public: '/api/v1/public/* (NO AUTH)',
        billing: '/api/v1/billing/* (NO AUTH - webhooks)',
        auth: '/api/v1/auth/* (NO AUTH - auth endpoints)',
        agents: '/api/v1/agents/* (PROTECTED)',
        products: '/api/v1/products/* (PROTECTED)',
        orders: '/api/v1/orders/* (PROTECTED)',
        conversations: '/api/v1/conversations/* (PROTECTED)',
        knowledgeBase: '/api/v1/knowledge-base/* (PROTECTED)',
        shops: '/api/v1/shops/* (PROTECTED)',
        chat: '/api/v1/chat/* (PROTECTED)'
      }
    }
  })

  // ‚úÖ CRITIQUE : ROUTES PUBLIQUES EN PREMIER (SANS AUTHENTIFICATION)
  fastify.register(async function (fastify) {
    // ‚úÖ RATE LIMITING SP√âCIFIQUE POUR LE WIDGET PUBLIC
    await fastify.register(rateLimit, {
      max: 500, // Plus permissif pour le widget public
      timeWindow: '1 minute',
      keyGenerator: (request) => {
        // Identifier par IP + shopId pour √©viter les abus
        const shopId = (request.params as any)?.shopId || (request.body as any)?.shopId || 'unknown'
        return `public-${request.ip}-${shopId}`
      }
    })

    // ‚úÖ ENREGISTRER LES ROUTES PUBLIQUES SANS AUTH
    fastify.register(publicRoutes)
    
    fastify.log.info('‚úÖ Routes publiques enregistr√©es SANS AUTH: /api/v1/public/*')
    
  }, { prefix: '/api/v1/public' })

  // ‚úÖ ROUTES BILLING (SANS AUTHENTIFICATION - Stripe webhooks)
  fastify.register(async function (fastify) {
    await fastify.register(rateLimit, {
      max: 100,
      timeWindow: '1 minute'
    })
    
    fastify.register(billingRoutes)
    fastify.log.info('‚úÖ Routes billing enregistr√©es SANS AUTH: /api/v1/billing/*')
    
  }, { prefix: '/api/v1/billing' })

  // ‚úÖ ROUTES D'AUTHENTIFICATION PUBLIQUES (SANS AUTH)
  fastify.register(async function (fastify) {
    
    await fastify.register(rateLimit, {
      max: 50,
      timeWindow: '1 minute'
    })
    
    // Route de login
    fastify.post('/login', async (request, reply) => {
      const { email, password } = request.body as any
      
      try {
        const { data, error } = await supabaseAuthClient.auth.signInWithPassword({
          email,
          password,
        })

        if (error) throw error

        return {
          success: true,
          user: data.user,
          session: data.session
        }
      } catch (error: any) {
        return reply.status(401).send({
          success: false,
          error: error.message || 'Erreur de connexion'
        })
      }
    })

    // Route de signup
    fastify.post('/signup', async (request, reply) => {
      const { email, password, metadata } = request.body as any
      
      try {
        const { data, error } = await supabaseAuthClient.auth.signUp({
          email,
          password,
          options: {
            data: metadata
          }
        })

        if (error) throw error

        return {
          success: true,
          user: data.user,
          session: data.session
        }
      } catch (error: any) {
        return reply.status(400).send({
          success: false,
          error: error.message || 'Erreur lors de l\'inscription'
        })
      }
    })
    
    fastify.log.info('‚úÖ Routes auth enregistr√©es SANS AUTH: /api/v1/auth/*')
    
  }, { prefix: '/api/v1/auth' })

  // ‚úÖ ROUTES API AVEC AUTHENTIFICATION OBLIGATOIRE
  fastify.register(async function (fastify) {
    
    // ‚úÖ MIDDLEWARE D'AUTH POUR TOUTES LES ROUTES API PROT√âG√âES
    fastify.addHook('preHandler', authenticate)
    
    // ‚úÖ ROUTES AGENTS
    fastify.register(agentsRoutes, { prefix: '/agents' })
    fastify.log.info('‚úÖ Routes agents enregistr√©es AVEC AUTH: /api/v1/agents/*')

    // ‚úÖ ROUTES PRODUITS 
    fastify.register(productsRoutes, { prefix: '/products' })
    fastify.log.info('‚úÖ Routes produits enregistr√©es AVEC AUTH: /api/v1/products/*')
    
    // ‚úÖ ROUTES COMMANDES
    fastify.register(ordersRoutes, { prefix: '/orders' })
    fastify.log.info('‚úÖ Routes commandes enregistr√©es AVEC AUTH: /api/v1/orders/*')

    // ‚úÖ ROUTES SHOPS
    fastify.register(shopsRoutes, { prefix: '/shops' })
    fastify.log.info('‚úÖ Routes shops enregistr√©es AVEC AUTH: /api/v1/shops/*')

    // ‚úÖ ROUTES KNOWLEDGE BASE
    fastify.register(knowledgeBaseRoutes, { prefix: '/knowledge-base' })
    fastify.log.info('‚úÖ Routes knowledge-base enregistr√©es AVEC AUTH: /api/v1/knowledge-base/*')

    // ‚úÖ ROUTES CONVERSATIONS
    fastify.register(conversationsRoutes, { prefix: '/conversations' })
    fastify.log.info('‚úÖ Routes conversations enregistr√©es AVEC AUTH: /api/v1/conversations/*')

    // ‚úÖ ROUTES CHAT INTERNE (pour le dashboard)
    fastify.register(chatRoutes, { prefix: '/chat' })
    fastify.log.info('‚úÖ Routes chat enregistr√©es AVEC AUTH: /api/v1/chat/*')

  }, { prefix: '/api/v1' })

  // ‚úÖ ROUTE DE FALLBACK POUR DEBUG
  fastify.setNotFoundHandler(async (request, reply) => {
    fastify.log.warn(`üîç Route non trouv√©e: ${request.method} ${request.url}`)
    return reply.status(404).send({
      success: false,
      error: 'Route not found',
      method: request.method,
      url: request.url,
      message: `Route ${request.method} ${request.url} not found`,
      availableRoutes: [
        'GET /health',
        'GET /',
        'POST /api/v1/auth/login (NO AUTH)',
        'POST /api/v1/auth/signup (NO AUTH)',
        'GET /api/v1/public/shops/public/:shopId/config (NO AUTH)',
        'POST /api/v1/public/chat (NO AUTH)',
        'POST /api/v1/billing/* (NO AUTH - webhooks)',
        'GET /api/v1/agents/* (PROTECTED)',
        'POST /api/v1/agents/* (PROTECTED)',
        'GET /api/v1/products/* (PROTECTED)',
        'POST /api/v1/products/* (PROTECTED)',
        'GET /api/v1/orders/* (PROTECTED)',
        'POST /api/v1/orders/* (PROTECTED)',
        'GET /api/v1/conversations/* (PROTECTED)',
        'POST /api/v1/conversations/* (PROTECTED)',
        'GET /api/v1/knowledge-base/* (PROTECTED)',
        'POST /api/v1/knowledge-base/* (PROTECTED)',
        'GET /api/v1/shops/* (PROTECTED)',
        'POST /api/v1/chat/* (PROTECTED)'
      ]
    })
  })
}

// ‚úÖ GRACEFUL SHUTDOWN AM√âLIOR√â
async function gracefulShutdown() {
  try {
    console.log('üõë Arr√™t du serveur en cours...')
    
    // Fermer les connexions Prisma proprement
    await prisma.$disconnect()
    console.log('‚úÖ Connexions Prisma ferm√©es')
    
    // Fermer Fastify
    await fastify.close()
    console.log('‚úÖ Serveur Fastify ferm√©')
    
    process.exit(0)
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'arr√™t:', error)
    process.exit(1)
  }
}

// Start server
async function start() {
  try {
    // ‚úÖ TEST CONNEXION DATABASE AVANT D√âMARRAGE
    console.log('üîß Test de connexion base de donn√©es...')
    const dbStatus = await testDatabaseConnection()
    
    if (!dbStatus.success) {
      console.error('‚ùå ERREUR CRITIQUE: Impossible de se connecter √† la base de donn√©es')
      console.error('üîç V√©rifiez votre DATABASE_URL')
      console.error('üìã Erreur:', dbStatus.error)
      process.exit(1)
    }
    
    console.log('‚úÖ Connexion base de donn√©es: OK')

    // ‚úÖ TEST CONNEXION SUPABASE AU D√âMARRAGE
    console.log('üîß Test de connexion Supabase...')
    const supabaseTest = await testSupabaseConnection()
    
    if (!supabaseTest.success) {
      console.error('‚ùå ERREUR CRITIQUE: Impossible de se connecter √† Supabase')
      console.error('üîç V√©rifiez vos variables SUPABASE_URL et SUPABASE_SERVICE_KEY')
      process.exit(1)
    }
    
    console.log('‚úÖ Connexion Supabase: OK')

    await registerPlugins()
    await registerRoutes()

    const port = parseInt(process.env.PORT || '3001')
    const host = '0.0.0.0'

    console.log('üöÄ === D√âMARRAGE RAILWAY DEBUG ===')
    console.log('üìä Environment:', process.env.NODE_ENV)
    console.log('üåê Host forc√© √†:', host)
    console.log('üîå Port:', port)
    console.log('üíæ Database URL pr√©sent:', !!process.env.DATABASE_URL)
    console.log('üîó Database URL preview:', process.env.DATABASE_URL?.substring(0, 80) + '...')
    console.log('================================')

    await fastify.listen({ port, host })
    
    console.log(`üöÄ ChatSeller API running on http://${host}:${port}`)
    console.log(`üìñ Health check: http://${host}:${port}/health`)
    console.log(`üè† Root: http://${host}:${port}/`)
    console.log('')
    console.log('üìå ROUTES PUBLIQUES (sans authentification):')
    console.log(`   üåê Config shop: GET /api/v1/public/shops/public/:shopId/config`)
    console.log(`   üí¨ Chat widget: POST /api/v1/public/chat`)
    console.log(`   üí≥ Billing webhooks: POST /api/v1/billing/*`)
    console.log(`   üîê Auth: POST /api/v1/auth/login | /api/v1/auth/signup`)
    console.log('')
    console.log('üîí ROUTES PROT√âG√âES (avec authentification):')
    console.log(`   ü§ñ Agents: /api/v1/agents/*`)
    console.log(`   üì¶ Products: /api/v1/products/*`)
    console.log(`   üõí Orders: /api/v1/orders/*`)
    console.log(`   üí¨ Conversations: /api/v1/conversations/*`)
    console.log(`   üìö Knowledge Base: /api/v1/knowledge-base/*`)
    console.log(`   üè™ Shops: /api/v1/shops/*`)
    console.log(`   üí≠ Chat interne: /api/v1/chat/*`)
    
  } catch (error) {
    fastify.log.error(error)
    process.exit(1)
  }
}

// Handle shutdown signals
process.on('SIGTERM', gracefulShutdown)
process.on('SIGINT', gracefulShutdown)

// ‚úÖ GESTION D'ERREURS NON CAPTUR√âES
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error)
  gracefulShutdown()
})

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason)
  gracefulShutdown()
})

// Start the server
start()