// routes/analytics/usage-stats.js 

const { PrismaClient } = require('@prisma/client')
const prisma = new PrismaClient()

/**
 * GET /api/v1/analytics/usage-stats
 * R√©cup√®re les statistiques d'utilisation du shop authentifi√©
 */
async function getUsageStatsHandler(request, reply) {
  try {
    const shopId = request.user.shopId || request.user.id
    const forceRefresh = request.query.forceRefresh === 'true'
    
    console.log('üìä R√©cup√©ration usage stats pour shop:', shopId)

    // ‚úÖ 1. R√âCUP√âRER LES CONVERSATIONS CE MOIS
    const startOfMonth = new Date()
    startOfMonth.setDate(1)
    startOfMonth.setHours(0, 0, 0, 0)
    
    const conversationsCount = await prisma.conversation.count({
      where: {
        shopId: shopId,
        createdAt: {
          gte: startOfMonth
        }
      }
    })

    // ‚úÖ 2. R√âCUP√âRER LES DOCUMENTS DE LA BASE DE CONNAISSANCE
    const documentsCount = await prisma.knowledgeBase.count({
      where: {
        shopId: shopId
      }
    })

    // ‚úÖ 3. R√âCUP√âRER LE NOMBRE D'AGENTS IA CR√â√âS
    const agentsCount = await prisma.agent.count({
      where: {
        shopId: shopId
      }
    })

    // ‚úÖ 4. R√âCUP√âRER LES COMMANDES CE MOIS
    const ordersCount = await prisma.order.count({
      where: {
        shopId: shopId,
        createdAt: {
          gte: startOfMonth
        }
      }
    })

    // ‚úÖ 5. CALCULER LE CHIFFRE D'AFFAIRES CE MOIS
    const revenueResult = await prisma.order.aggregate({
      where: {
        shopId: shopId,
        createdAt: {
          gte: startOfMonth
        },
        status: {
          in: ['completed', 'paid']
        }
      },
      _sum: {
        totalAmount: true
      }
    })

    const totalRevenue = revenueResult._sum.totalAmount || 0

    // ‚úÖ 6. CALCULER LE TAUX DE CONVERSION
    let conversionRate = 0
    if (conversationsCount > 0) {
      conversionRate = (ordersCount / conversationsCount) * 100
    }

    // ‚úÖ 7. R√âCUP√âRER DES M√âTRIQUES SUPPL√âMENTAIRES
    const [
      totalConversations,
      activeConversations,
      averageResponseTime,
      customerSatisfaction
    ] = await Promise.all([
      // Total conversations toutes p√©riodes
      prisma.conversation.count({
        where: { shopId: shopId }
      }),
      
      // Conversations actives (derni√®res 24h)
      prisma.conversation.count({
        where: {
          shopId: shopId,
          updatedAt: {
            gte: new Date(Date.now() - 24 * 60 * 60 * 1000)
          }
        }
      }),

      // Temps de r√©ponse moyen (mock pour l'instant)
      Promise.resolve(2.3),

      // Satisfaction client moyenne (mock pour l'instant)
      Promise.resolve(4.7)
    ])

    // ‚úÖ 8. CONSTRUIRE LA R√âPONSE
    const usageStats = {
      // M√©triques principales
      conversations: conversationsCount,
      documents: documentsCount,
      agents: agentsCount,
      orders: ordersCount,
      totalRevenue: parseFloat(totalRevenue.toFixed(2)),
      conversionRate: parseFloat(conversionRate.toFixed(2)),
      
      // M√©triques suppl√©mentaires
      totalConversations,
      activeConversations,
      averageResponseTime,
      customerSatisfaction,
      
      // M√©tadonn√©es
      period: 'current_month',
      lastUpdated: new Date().toISOString(),
      shopId: shopId
    }

    console.log('‚úÖ Usage stats calcul√©es:', usageStats)

    return reply.code(200).send({
      success: true,
      data: usageStats,
      meta: {
        period: 'current_month',
        generatedAt: new Date().toISOString(),
        cacheEnabled: !forceRefresh
      }
    })

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des usage stats:', error)
    
    return reply.code(500).send({
      success: false,
      error: 'Erreur serveur lors de la r√©cup√©ration des statistiques',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
}

/**
 * GET /api/v1/analytics/usage-stats/detailed
 * R√©cup√®re des statistiques d√©taill√©es avec historique
 */
async function getDetailedUsageStatsHandler(request, reply) {
  try {
    const shopId = request.user.shopId || request.user.id
    const { period = '30d', metric = 'all' } = request.query
    
    console.log('üìä R√©cup√©ration usage stats d√©taill√©es pour shop:', shopId)

    // Calculer la p√©riode
    let startDate = new Date()
    switch (period) {
      case '7d':
        startDate.setDate(startDate.getDate() - 7)
        break
      case '30d':
        startDate.setDate(startDate.getDate() - 30)
        break
      case '90d':
        startDate.setDate(startDate.getDate() - 90)
        break
      case '1y':
        startDate.setFullYear(startDate.getFullYear() - 1)
        break
      default:
        startDate.setDate(startDate.getDate() - 30)
    }

    // ‚úÖ R√âCUP√âRER L'HISTORIQUE DES CONVERSATIONS PAR JOUR
    const conversationHistory = await prisma.conversation.groupBy({
      by: ['createdAt'],
      where: {
        shopId: shopId,
        createdAt: {
          gte: startDate
        }
      },
      _count: {
        id: true
      },
      orderBy: {
        createdAt: 'asc'
      }
    })

    // ‚úÖ R√âCUP√âRER L'HISTORIQUE DES COMMANDES PAR JOUR
    const orderHistory = await prisma.order.groupBy({
      by: ['createdAt'],
      where: {
        shopId: shopId,
        createdAt: {
          gte: startDate
        }
      },
      _count: {
        id: true
      },
      _sum: {
        totalAmount: true
      },
      orderBy: {
        createdAt: 'asc'
      }
    })

    // ‚úÖ R√âCUP√âRER LES TOP PRODUITS
    const topProducts = await prisma.orderItem.groupBy({
      by: ['productId'],
      where: {
        order: {
          shopId: shopId,
          createdAt: {
            gte: startDate
          }
        }
      },
      _count: {
        id: true
      },
      _sum: {
        quantity: true,
        price: true
      },
      orderBy: {
        _count: {
          id: 'desc'
        }
      },
      take: 10
    })

    const detailedStats = {
      period: period,
      startDate: startDate.toISOString(),
      endDate: new Date().toISOString(),
      
      // Historiques
      conversationHistory: conversationHistory.map(item => ({
        date: item.createdAt.toISOString().split('T')[0],
        count: item._count.id
      })),
      
      orderHistory: orderHistory.map(item => ({
        date: item.createdAt.toISOString().split('T')[0],
        count: item._count.id,
        revenue: parseFloat((item._sum.totalAmount || 0).toFixed(2))
      })),
      
      topProducts: topProducts.map((item, index) => ({
        rank: index + 1,
        productId: item.productId,
        orders: item._count.id,
        quantity: item._sum.quantity || 0,
        revenue: parseFloat((item._sum.price || 0).toFixed(2))
      })),
      
      // M√©triques de performance
      performance: {
        totalConversations: conversationHistory.reduce((sum, item) => sum + item._count.id, 0),
        totalOrders: orderHistory.reduce((sum, item) => sum + item._count.id, 0),
        totalRevenue: orderHistory.reduce((sum, item) => sum + (item._sum.totalAmount || 0), 0),
        averageOrderValue: orderHistory.length > 0 
          ? (orderHistory.reduce((sum, item) => sum + (item._sum.totalAmount || 0), 0) / orderHistory.reduce((sum, item) => sum + item._count.id, 0))
          : 0
      }
    }

    return reply.code(200).send({
      success: true,
      data: detailedStats,
      meta: {
        period,
        metric,
        generatedAt: new Date().toISOString()
      }
    })

  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des stats d√©taill√©es:', error)
    
    return reply.code(500).send({
      success: false,
      error: 'Erreur serveur lors de la r√©cup√©ration des statistiques d√©taill√©es',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    })
  }
}

// ‚úÖ EXPORT DES HANDLERS
module.exports = {
  getUsageStatsHandler,
  getDetailedUsageStatsHandler
}

// ‚úÖ CONFIGURATION DES ROUTES FASTIFY
// √Ä ajouter dans votre fichier de routes principal

/*
// Dans routes/analytics.js ou app.js :

const { 
  getUsageStatsHandler, 
  getDetailedUsageStatsHandler 
} = require('./analytics/usage-stats')

// Routes prot√©g√©es (n√©cessitent authentification)
app.register(async function (app) {
  // Middleware d'authentification
  app.addHook('preHandler', async (request, reply) => {
    try {
      // V√©rifier le token d'authentification
      const authHeader = request.headers.authorization
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        throw new Error('Token manquant')
      }
      
      const token = authHeader.substring(7)
      const user = await verifyAuthToken(token) // Votre fonction de v√©rification
      
      request.user = user
    } catch (error) {
      reply.code(401).send({ 
        success: false, 
        error: 'Non authentifi√©' 
      })
    }
  })

  // Routes analytics
  app.get('/api/v1/analytics/usage-stats', getUsageStatsHandler)
  app.get('/api/v1/analytics/usage-stats/detailed', getDetailedUsageStatsHandler)
})
*/